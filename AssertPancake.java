import java.util.Random;
import java.util.Scanner;

public class AssertPancake {


    public static int TEST_COUNT = 10;
    public static int MIN_STACK_COUNT = 4;
    public static int STACK_COUNT_VARIANCE = 3;
    
    /**
     * This is my testing main function
     * @param args
     */
    public static void main(String[] args) {
        if (args.length >= 1){
            if (args[0].compareTo("0") == 0){
                main2(args);
                return;
            }
            TEST_COUNT = Integer.parseInt(args[0]);
        }
        if (args.length >= 2){
            MIN_STACK_COUNT = Integer.parseInt(args[1]);
        }
        if (args.length >= 3){
            STACK_COUNT_VARIANCE = Integer.parseInt(args[2]);
        }
        String input;
        String output;
        Random rng = new Random(System.currentTimeMillis());
        double successes = 0;
        double ratio = 0.0;
        for (int i = 0; i < TEST_COUNT; i++) {
            input = generateInput(rng);
            output = generateOutput(input);
            boolean result = AssertPancake.assertTrue(input, output);
            if (result) {successes+=1;}
//            if (!result) {
                System.out.println(result + "\t" + input + " : " + output);
//            }
            ratio += retrieveFirstNum(output) / retrieveFirstNum(input);
        }
        double rate = successes / TEST_COUNT;
        ratio = ratio / TEST_COUNT;
        System.out.println("success rate: " + rate);
        System.out.println("average flip ratio [number of flips]/ [stack size]: " + ratio);
    }

    private static void main2(String[] args){
        StringBuilder sb = new StringBuilder();
        int i = 1;
        if (args.length >= 2)sb.append(args[i++]);
        while (i < args.length) {
            sb.append(" ");
            sb.append(args[i++]);
        }
        String input = sb.toString();
        String output = generateOutput(input);
        System.out.println("test input: " + input + "\nTest output: " + output + "\nAssert: " + AssertPancake.assertTrue(input, output));
    }

    /**
     * This function returns the output string generated by FlipPancakes Code, if testing other stuff, replace with your code.
     *
     * @param input  This is a properly formated input string
     * @return output  This is a properly formated output string
     */
    private static String generateOutput(String input){
        return (new FlipPancakes(input, new ListStack<Integer>())).getResult();
    }

    /**
     * This function returns a random properly formated input string, if testing other stuff, replace with your code.
     *
     * @param input  This is a properly formated input string
     * @return output  This is a properly formated output string
     */
    private static String generateInput(Random rng){
        return (new AssertPancake(rng)).toString();
    }

    private static double retrieveFirstNum(String s){
        Scanner reader = new Scanner(s);
        double x = reader.nextInt();
        reader.close();
        return x;
    }

    public static boolean assertTrue(String argument, String solution){
        AssertPancake data = new AssertPancake(argument);
        data.flipset(solution);
        return data.isOrdered();
    }

    private Stack<Integer> _stack;

    /**
     * generates a pancake stack based on input string
     * @param input
     */
    public AssertPancake(String input){
        _stack = new ArrayStack<>();
        Stack<Integer> tempstack = new ArrayStack<>();
        Scanner in = new Scanner(input);
        int length = in.nextInt();
        for(int i = 0; i < length; i++){
            tempstack.push(in.nextInt());
        }
        while(!tempstack.isEmpty()){
            _stack.push(tempstack.pop());
        }
    }

    /**
     * generates random pancake stack
     */
    public AssertPancake(Random r){
        //random array generation, unique magnitudes and nonzero.
        int[] arr = new int[r.nextInt(STACK_COUNT_VARIANCE) + MIN_STACK_COUNT];
        for(int i : arr){
            i = 0;
        }
        int fillsize = arr.length;
        while (fillsize > 0){
            int indexpick = r.nextInt(fillsize); //when this is zero push into first zero entry
            int i = 0;
            while(indexpick > 0 || arr[i] != 0){
                if (arr[i] == 0) {
                    indexpick--;
                }
                i++;
            }
            if (r.nextInt() % 2 == 1){
                arr[i] = fillsize;
            } else {
                arr[i] = -fillsize;
            }
            fillsize--;
        }
        //push into stack
        _stack = new ArrayStack<>();
        for(int i : arr){
            _stack.push(i);
        }
    }

    public void flip(int count) {
        Queue<Integer> queue = new LinkedQueue<>();
        for (int i = 0; i < count; i++) {
            queue.enqueue(_stack.pop());
        }
        for (int i = 0; i < count; i++) {
            _stack.push(-1 * queue.dequeue());
        }
    }

    public void flipset(String solution) {
        Scanner in = new Scanner(solution);
        int length = in.nextInt();
        for(int i = 0; i < length; i++){
            flip(in.nextInt());
        }
    }

    public boolean isOrdered(){
        Stack<Integer> tempstack = new ListStack<>();
        boolean retval = true;//assume true
        int lastval = 0;
        while (!_stack.isEmpty()){
            int temp = _stack.pop();
            tempstack.push(temp);
            if (temp < lastval){// last pancake is larger than the one benieth it, or burnt up.
                retval = false;//proven false
                break;
            }
            lastval = temp;
        }
        while(!tempstack.isEmpty()){
            _stack.push(tempstack.pop());
        }
        return retval;
    }

    /**
     * Prints a potential input string representation of current state and preserves data.
     *
     * @return String conforming to pankaken input standards
     */
    @Override
    public String toString(){
        StringBuilder ret = new StringBuilder();
        ret.append(_stack.size());
        Stack<Integer> tempstack = new ListStack<>();
        while (!_stack.isEmpty()){
            ret.append(' ');
            int temp = _stack.pop();
            tempstack.push(temp);
            if (temp > 0){
                ret.append('+');
            } else if (temp < 0) {
                ret.append('-');
            }
            ret.append(java.lang.Math.abs(temp));// JAVA STANDARD ABSOLUTE VALUE FUNCTION
        }
        while(!tempstack.isEmpty()){
            _stack.push(tempstack.pop());
        }
        return ret.toString();
    }
}
